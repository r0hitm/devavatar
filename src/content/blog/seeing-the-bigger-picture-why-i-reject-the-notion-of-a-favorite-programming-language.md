---
title: "Seeing the Bigger Picture: Why I Reject the Notion of a Favorite Programming Language"
description: Why choosing programming languages based on the problem at hand, rather than personal preference, leads to more effective and elegant solutions.
pubDatetime: 2023-06-15T00:00:00.000Z
modDatetime: 2024-03-25T04:25:36.085Z
tags:
  - review
  - programming
---

> **"You should not have a favorite weapon. To become over-familiar with one weapon is as much a fault as not knowing it sufficiently well."**
>
> \- Miyamoto Musashi

## Table of Contents

## Introduction

Recently, I completed the Programming Languages [Part A](https://www.coursera.org/learn/programming-languages), [Part B](https://www.coursera.org/learn/programming-languages-part-b), and [Part C](https://www.coursera.org/learn/programming-languages-part-c) MOOCs, which provided me with a valuable perspective on programming languages. This blog post serves as a course review and an exploration of my stance on the idea of having a favorite programming language.

## Key Ideas Explored in the Courses

Throughout the course, I delved into fundamental programming language concepts with a strong emphasis on functional programming in parts A and B. Part C focuses on Object-Oriented Programming and how they both are similar and different.

### Part A

- Functional programming concepts, including closures, [lexical scoping](https://hashnode.com/post/clgwfm8mw000c09lfcxqfex2o), recursion, currying, and type inference

### Part B

- Dynamic typing using Racket and covered topics such as thunking, lazy evaluation, streams, and memoization

- The distinction between compiled and interpreted languages, emphasizes that this categorization pertains to language implementation, not the language specification.

- (Developed an interpreter as part of the course assignments)

- Static checking, [correctness (soundness and completeness), and weak typing](https://hashnode.com/post/clh32q50s000208l9gy1bbcnu).

### Part C

- Ruby as a dynamic language and object-oriented programming (OOP) concepts within this context

- Subclassing, polymorphism, [double dispatch](https://hashnode.com/post/clhd1cf9x00000amf0l2v5pe6), mixins, interfaces, and abstract methods

- [Subtyping](https://hashnode.com/post/clhngd6vb000009mp457uht2u)

## Insights and Paradigm Shift

Completing the course led to a significant paradigm shift in my perception of programming languages. I realized that each language possesses its unique strengths and weaknesses, making them more suitable for specific problem domains. Having a favorite programming language often blinds us to the possibility of finding more elegant and efficient solutions in other languages. This notion was exemplified by the course itself, which utilized three different languages to teach appropriate concepts for each.

The ultimate goal of programming is to develop software solutions efficiently and effectively. To achieve this, it is crucial to select the right tools that align with the objective at hand. The course enabled me to transcend language-specific syntax and focus on program design, gaining a broader understanding of various concepts employed by different languages. This newfound perspective allows me to approach programming challenges agnostically, reasoning about design independently of specific languages. Additionally, I have discovered that with a strong foundation in programming concepts, learning new languages and frameworks becomes a manageable task.

Ask yourself these questions when learning a programming language:

1. **Syntax:** How do I write it?

2. **Semantics:** What is the meaning behind the syntax?

3. **Idioms:** What are typical patterns and best practices in the language?

4. **Libraries:** How to do specific things such as file access? In any language, there are things that one cannot do without library support.

5. **Tools:** What are the tools that make it easy/efficient to program in that language? Such as REPLs, debuggers, and code formatters etc. However, note that these tools are not inherently part of the language itself.

## Conclusion

Embracing a language-agnostic approach to programming opens up a world of possibilities. By considering broader aspects of program design and leveraging concepts from various languages, developers can create efficient and elegant solutions. It is essential to remember that programming languages are tools at our disposal, and the choice of language should align with the problem.

![hacker matrix gif](https://media.tenor.com/LQ_hjkLNJDkAAAAC/hacker-matrix.gif)
